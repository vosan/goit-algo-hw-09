# goit-algo-hw-09

Цей репозиторій показує два способи видати решту для монет [50, 25, 10, 5, 2, 1]:
- find_coins_greedy(amount) - жадібний підхід
- find_min_coins(amount) - динамічне програмування


Коротко про швидкість і памʼять

1) Жадібний алгоритм (find_coins_greedy)
- Проходить по номіналах від найбільшого до найменшого і бере скільки можна
- Час O(k), де k - кількість номіналів. Для фіксованого набору це майже константа
- Памʼять O(1) додатково
- На великих сумах працює дуже швидко, бо k не змінюється

2) Динамічне програмування (find_min_coins)
- Рахує мінімальну кількість монет для всіх сум від 0 до amount
- Час O(k*amount), памʼять O(amount)
- На великих сумах може бути повільно і вимагати багато памʼяті
- Плюс: завжди знаходить мінімум навіть для нестандартних наборів номіналів, де greedy може помилятися

Коли який підхід брати
- Для наших номіналів greedy і швидкий, і дає оптимальну відповідь
- Якщо номінали інші і немає гарантії оптимальності greedy, беріть DP, але зважайте на час і памʼять

Маленький тест часу (локально)

```python
from time import perf_counter
from coins import find_coins_greedy, find_min_coins

def bench(fn, amount):
    t0 = perf_counter()
    _ = fn(amount)
    return perf_counter() - t0

for a in [10**3, 10**4, 10**5]:
    tg = bench(find_coins_greedy, a)
    td = bench(find_min_coins, a)
    print(f"amount={a:>6} | greedy: {tg*1e6:8.1f} µs | dp: {td*1e6:8.1f} µs")
```

Очікування
- greedy змінюється мало з ростом суми
- dp росте приблизно лінійно з amount

Приклад використання

```python
from coins import find_coins_greedy, find_min_coins

print(find_coins_greedy(113))  # {50: 2, 10: 1, 2: 1, 1: 1}
print(find_min_coins(113))     # {1: 1, 2: 1, 10: 1, 50: 2}
```
